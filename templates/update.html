<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Software Update - {{ display_name }}</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 24px;
    }

    .row {
      margin-bottom: 12px;
    }

    button {
      padding: 8px 14px;
      font-weight: bold;
    }

    a.btn {
      text-decoration: none;
      display: inline-block;
      padding: 8px 14px;
      border-radius: 6px;
      background: #f0f0f0;
      color: #000;
      font-weight: 700;
      border: 1px solid #ddd;
    }

    a.btn:hover {
      background: #e6e6e6;
    }

    #console {
      background: #111;
      color: #ddd;
      padding: 12px;
      border-radius: 6px;
      min-height: 220px;
      white-space: pre-wrap;
      overflow: auto;
    }

    #status {
      margin-top: 8px;
      color: #666;
    }

    #rebootBtn {
      display: none;
    }

    #successLabel {
      display: none;
      background: #e8f5e9;
      color: #2a7a2a;
      padding: 10px 12px;
      border-radius: 6px;
      font-weight: bold;
      margin-top: 8px;
    }

    /* Reboot waiting overlay */
    #rebootOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #rebootOverlay.visible {
      display: flex;
    }

    .spinner {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 255, 255, 0.2);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 24px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    #rebootOverlay .message {
      color: #fff;
      font-size: 18px;
      text-align: center;
      max-width: 300px;
    }

    #rebootOverlay .submessage {
      color: #aaa;
      font-size: 14px;
      margin-top: 12px;
      text-align: center;
    }

    #rebootOverlay .error-message {
      color: #ff6b6b;
      font-size: 16px;
      margin-top: 16px;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="row">
      <a href="{{ url_for('index') }}" class="btn">‚Üê Back</a>
    </div>
    <h2>Software Update</h2>

    <!-- Background Update Check Interval Section -->
    <div class="interval-section">
      <h3>Background Update Check Interval</h3>
      <div class="row" style="display: flex; align-items: center; gap: 12px;">
        <label for="checkInterval" style="min-width: auto;">Check every</label>
        <input type="number" id="checkInterval" min="5" max="3600" step="1" value="{{ update_check_interval }}"
          style="width: 80px; padding: 6px; font-size: 14px;">
        <span>seconds</span>
        <button type="button" id="saveIntervalBtn">Save</button>
      </div>
      <div class="row" style="color:#666; margin-top: 8px;">
        <span id="lastSaved">Last saved: {{ last_saved }}</span>
      </div>
      <div id="intervalStatus" class="row" style="color: #666; font-size: 14px;"></div>
    </div>

    <hr style="margin: 24px 0; border: none; border-top: 1px solid #ddd;">

    <!-- Run Update Section -->
    <h3>Run Update</h3>
    <div class="row">
      <button id="runUpdate">Run Update</button>
      <button id="rebootBtn">Reboot System</button>
    </div>
    <div id="status" class="row"></div>
    <pre id="console" class="row"></pre>
    <div id="successLabel" class="row"></div>
  </div>

  <!-- Reboot waiting overlay -->
  <div id="rebootOverlay">
    <div class="spinner"></div>
    <div class="message">Waiting for system to come back online...</div>
    <div class="submessage">This may take up to 2 minutes</div>
    <div id="rebootError" class="error-message" style="display: none;"></div>
  </div>

  <script>
    const runBtn = document.getElementById('runUpdate');
    const rebootBtn = document.getElementById('rebootBtn');
    const consoleEl = document.getElementById('console');
    const statusEl = document.getElementById('status');
    const successLabelEl = document.getElementById('successLabel');

    let evtSource = null;

    function clearConsole() { consoleEl.textContent = ''; }
    function appendLine(line) { consoleEl.textContent += (line.endsWith('\n') ? line : line + '\n'); consoleEl.scrollTop = consoleEl.scrollHeight; }
    function setStatus(text, color = '#666') { statusEl.textContent = text; statusEl.style.color = color; }
    function disableRun(disabled) { runBtn.disabled = disabled; }
    function showReboot(show) { rebootBtn.style.display = show ? 'inline-block' : 'none'; }
    function showSuccessLabel(message) { successLabelEl.textContent = 'Installed Update: ' + message; successLabelEl.style.display = 'block'; }
    function hideSuccessLabel() { successLabelEl.style.display = 'none'; }

    function closeEventSource() {
      if (evtSource) { evtSource.close(); evtSource = null; }
    }

    runBtn.addEventListener('click', () => {
      clearConsole();
      hideSuccessLabel();
      showReboot(false);
      setStatus('Running update...');
      disableRun(true);
      closeEventSource();

      evtSource = new EventSource('/api/update/run');
      evtSource.onmessage = (e) => {
        if (e && typeof e.data === 'string' && e.data.length) {
          appendLine(e.data);
        }
      };
      evtSource.addEventListener('done', (e) => {
        disableRun(false);
        try {
          const payload = JSON.parse(e.data || '{}');
          if (payload.has_error) {
            setStatus('Error updating. See console for details.', '#cc3333');
            showReboot(false);
          } else if (payload.has_updates) {
            setStatus('Update completed. Reboot required.', '#d49200');
            showReboot(true);
            if (payload.commit_message) {
              showSuccessLabel(payload.commit_message);
            }
          } else {
            setStatus('Already up to date.', '#2a7a2a');
            showReboot(false);
          }
        } catch {
          setStatus('Update finished.');
        }
        closeEventSource();
      });
      evtSource.onerror = () => {
        disableRun(false);
        setStatus('Connection error during update.', '#cc3333');
        closeEventSource();
      };
    });

    rebootBtn.addEventListener('click', async () => {
      setStatus('Rebooting system...');

      try {
        await fetch('/api/reboot', { method: 'POST' });
      } catch (e) {
        // Expected - connection may drop immediately
      }

      // Show the overlay and start polling
      const overlay = document.getElementById('rebootOverlay');
      const errorEl = document.getElementById('rebootError');
      overlay.classList.add('visible');

      const homeUrl = '{{ url_for("index") }}';
      const pollInterval = 2000; // 2 seconds
      const maxWaitTime = 120000; // 120 seconds
      const startTime = Date.now();

      async function checkServerAvailable() {
        const elapsed = Date.now() - startTime;

        if (elapsed > maxWaitTime) {
          errorEl.textContent = 'Timeout: Server did not come back online within 2 minutes.';
          errorEl.style.display = 'block';
          return;
        }

        try {
          const response = await fetch(homeUrl, {
            method: 'HEAD',
            cache: 'no-store'
          });

          if (response.ok) {
            // Server is back! Redirect to home page
            window.location.href = homeUrl;
            return;
          }
        } catch (e) {
          // Server not ready yet, continue polling
        }

        // Schedule next check
        setTimeout(checkServerAvailable, pollInterval);
      }

      // Wait a bit before starting to poll (give server time to shut down)
      setTimeout(checkServerAvailable, 3000);
    });

    // Interval save handler
    const saveIntervalBtn = document.getElementById('saveIntervalBtn');
    const checkIntervalInput = document.getElementById('checkInterval');
    const intervalStatusEl = document.getElementById('intervalStatus');
    const lastSavedEl = document.getElementById('lastSaved');

    // Mark as unsaved when interval changes
    function markUnsaved() {
      if (lastSavedEl) lastSavedEl.style.color = '#cc6666';
    }

    checkIntervalInput.addEventListener('input', markUnsaved);
    checkIntervalInput.addEventListener('change', markUnsaved);

    saveIntervalBtn.addEventListener('click', async () => {
      let interval = parseInt(checkIntervalInput.value, 10);

      // Validate bounds
      if (isNaN(interval) || interval < 5) {
        interval = 5;
        checkIntervalInput.value = 5;
      } else if (interval > 3600) {
        interval = 3600;
        checkIntervalInput.value = 3600;
      }

      saveIntervalBtn.disabled = true;
      saveIntervalBtn.textContent = 'Saving...';

      try {
        const response = await fetch('/api/update-check-interval', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ interval: interval })
        });

        const data = await response.json();

        if (data.success) {
          intervalStatusEl.textContent = 'Saved! The display will check for updates every ' + data.interval + ' seconds.';
          intervalStatusEl.style.color = '#2a7a2a';
          // Update last saved label
          const now = new Date();
          const timeStr = now.toLocaleString('en-US', {
            month: '2-digit',
            day: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
          lastSavedEl.textContent = 'Last saved: ' + timeStr;
          lastSavedEl.style.color = '#666';
        } else {
          intervalStatusEl.textContent = 'Error: ' + (data.error || 'Unknown error');
          intervalStatusEl.style.color = '#cc3333';
        }
      } catch (e) {
        intervalStatusEl.textContent = 'Error: ' + e.message;
        intervalStatusEl.style.color = '#cc3333';
      }

      saveIntervalBtn.disabled = false;
      saveIntervalBtn.textContent = 'Save';
    });
  </script>
</body>

</html>