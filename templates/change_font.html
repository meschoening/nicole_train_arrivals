{% extends "_layout.html" %}
{% set page_title = "Change Font" %}
{% set page_subtitle = "Update the typeface used on the display." %}
{% set active_page = "change_font" %}

{% block head_extra %}
<style>
  {% for font in fonts %}
  @font-face {
    font-family: '{{ font.name }}';
    src: url('/api/font-file/{{ font.name | urlencode }}') format('truetype');
    font-display: swap;
  }
  {% endfor %}

  .font-list {
    max-height: 420px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    background: var(--surface-muted);
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .font-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-subtle);
    background: var(--surface);
    cursor: pointer;
  }

  .font-item.selected {
    border-color: var(--accent);
    background: var(--accent-weak);
    color: var(--accent);
  }

  .font-item input[type="radio"] {
    position: absolute;
    opacity: 0;
  }

  .font-preview {
    font-size: 13px;
    flex: 1;
  }

  .font-indicator {
    width: 12px;
    height: 12px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: var(--surface-muted);
  }

  .font-item.selected .font-indicator {
    border-color: var(--accent);
    background: var(--accent);
  }

  .status-message {
    margin-top: 12px;
    padding: 12px 16px;
    border-radius: var(--radius-sm);
    display: none;
  }

  .status-message.success {
    background: rgba(31, 122, 93, 0.12);
    color: var(--success);
    border: 1px solid rgba(31, 122, 93, 0.4);
  }

  .status-message.error {
    background: rgba(192, 55, 43, 0.12);
    color: var(--danger);
    border: 1px solid rgba(192, 55, 43, 0.4);
  }

  .upload-actions {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }

  .current-font-display {
    font-size: 2em;
  }
</style>
{% endblock %}

{% block content %}
<div class="content-grid">
  <div class="card">
    <div class="card-title">Current font</div>
    <div class="field">
      <div class="field-label">
        <span id="currentFontDisplay" class="current-font-display" style="font-family: '{{ current_font }}';">{{ current_font }}</span>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">Installed fonts</div>
    <div class="card-subtitle">Select a font to apply on the next restart.</div>
    <div class="font-list" id="fontList">
      {% for font in fonts %}
      <div class="font-item {% if font.name == current_font %}selected{% endif %}" data-font="{{ font.name }}">
        <input type="radio" name="font" value="{{ font.name }}" {% if font.name==current_font %}checked{% endif %}>
        <span class="font-indicator"></span>
        <span class="font-preview" style="font-family: '{{ font.name }}';">{{ font.name }}</span>
      </div>
      {% endfor %}
    </div>
    <div class="field-control" style="margin-top: 12px;">
      <button type="button" id="applyBtn" class="button button-primary" disabled>Apply selected font</button>
      <button type="button" id="revertBtn" class="button">Revert to default ({{ default_font }})</button>
    </div>
    <div id="statusMessage" class="status-message"></div>
  </div>

  <div class="card">
    <div class="card-title">Install new font</div>
    <div class="card-subtitle">Upload a .ttf or .otf file (max 10MB).</div>
    <div class="upload-actions">
      <button type="button" class="button" id="fontSelectBtn">Choose font file</button>
      <span class="field-hint" id="fontFileName">No file selected.</span>
      <input type="file" id="fontFileInput" accept=".ttf,.otf" hidden>
    </div>
    <div class="field-control" style="margin-top: 12px;">
      <button type="button" id="uploadBtn" class="button button-primary" disabled>Upload and install</button>
      <span id="uploadProgress" class="field-hint"></span>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
  const fontList = document.getElementById('fontList');
  const applyBtn = document.getElementById('applyBtn');
  const revertBtn = document.getElementById('revertBtn');
  const statusMessage = document.getElementById('statusMessage');
  const currentFontDisplay = document.getElementById('currentFontDisplay');
  const fontSelectBtn = document.getElementById('fontSelectBtn');
  const fontFileInput = document.getElementById('fontFileInput');
  const fontFileName = document.getElementById('fontFileName');
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadProgress = document.getElementById('uploadProgress');

  let selectedFont = '{{ current_font }}';
  let savedFont = '{{ current_font }}';
  let pendingRestart = false;

  fontList.addEventListener('click', (e) => {
    const item = e.target.closest('.font-item');
    if (!item) return;
    document.querySelectorAll('.font-item').forEach(el => el.classList.remove('selected'));
    item.classList.add('selected');
    item.querySelector('input[type="radio"]').checked = true;
    selectedFont = item.dataset.font;
    updateApplyButton();
  });

  function updateApplyButton() {
    if (pendingRestart) {
      applyBtn.textContent = 'Restart app';
      applyBtn.disabled = false;
    } else {
      applyBtn.textContent = 'Apply selected font';
      applyBtn.disabled = selectedFont === savedFont;
    }
  }

  function showStatus(message, isError = false) {
    statusMessage.textContent = message;
    statusMessage.className = 'status-message ' + (isError ? 'error' : 'success');
    statusMessage.style.display = 'block';
  }

  function hideStatus() {
    statusMessage.style.display = 'none';
  }

  applyBtn.addEventListener('click', async () => {
    if (pendingRestart) {
      applyBtn.disabled = true;
      applyBtn.textContent = 'Restarting...';
      try {
        const res = await fetch('/api/restart-app', { method: 'POST', headers: { 'X-CSRF-Token': csrfToken } });
        const data = await res.json();
        if (data.success) {
          showStatus('Restarting application... Page will reload when ready.');
          waitForServerAndReload();
        } else {
          showStatus(data.error || 'Failed to restart', true);
          applyBtn.disabled = false;
          updateApplyButton();
        }
      } catch (err) {
        showStatus('Restarting application... Page will reload when ready.');
        waitForServerAndReload();
      }
      return;
    }

    applyBtn.disabled = true;
    hideStatus();

    try {
      const res = await fetch('/api/font', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
        body: JSON.stringify({ font_family: selectedFont })
      });
      const data = await res.json();

      if (data.success) {
        savedFont = selectedFont;
        currentFontDisplay.textContent = selectedFont;
        currentFontDisplay.style.fontFamily = `'${selectedFont}'`;
        pendingRestart = true;
        updateApplyButton();
        showStatus('Font changed! Click "Restart app" to apply changes.');
      } else {
        showStatus(data.error || 'Failed to save font', true);
        applyBtn.disabled = false;
      }
    } catch (err) {
      showStatus('Error: ' + err.message, true);
      applyBtn.disabled = false;
    }
  });

  function waitForServerAndReload() {
    const checkInterval = 500;
    const maxWait = 30000;
    let elapsed = 0;

    const pollServer = () => {
      fetch('/change-font', { method: 'HEAD' })
        .then(response => {
          if (response.ok) {
            window.location.reload();
          } else {
            scheduleNextPoll();
          }
        })
        .catch(() => {
          scheduleNextPoll();
        });
    };

    const scheduleNextPoll = () => {
      elapsed += checkInterval;
      if (elapsed < maxWait) {
        setTimeout(pollServer, checkInterval);
      } else {
        showStatus('Server did not respond. Please reload the page manually.', true);
        applyBtn.disabled = false;
        updateApplyButton();
      }
    };

    setTimeout(pollServer, 1000);
  }

  revertBtn.addEventListener('click', async () => {
    revertBtn.disabled = true;
    hideStatus();

    try {
      const res = await fetch('/api/font/revert', { method: 'POST', headers: { 'X-CSRF-Token': csrfToken } });
      const data = await res.json();

      if (data.success) {
        savedFont = data.font_family;
        selectedFont = data.font_family;
        currentFontDisplay.textContent = data.font_family;
        currentFontDisplay.style.fontFamily = `'${data.font_family}'`;

        document.querySelectorAll('.font-item').forEach(el => {
          if (el.dataset.font === data.font_family) {
            el.classList.add('selected');
            el.querySelector('input[type="radio"]').checked = true;
          } else {
            el.classList.remove('selected');
            el.querySelector('input[type="radio"]').checked = false;
          }
        });

        pendingRestart = true;
        updateApplyButton();
        showStatus('Font reverted to default! Click "Restart app" to apply changes.');
      } else {
        showStatus(data.error || 'Failed to revert font', true);
      }
    } catch (err) {
      showStatus('Error: ' + err.message, true);
    }

    revertBtn.disabled = false;
  });

  updateApplyButton();

  fontSelectBtn.addEventListener('click', () => {
    fontFileInput.click();
  });

  fontFileInput.addEventListener('change', () => {
    const hasFile = fontFileInput.files && fontFileInput.files.length > 0;
    uploadBtn.disabled = !hasFile;
    if (hasFile) {
      fontFileName.textContent = fontFileInput.files[0].name;
    } else {
      fontFileName.textContent = 'No file selected.';
    }
    uploadProgress.textContent = '';
  });

  function showUploadProgress(message, isError = false, isSuccess = false) {
    uploadProgress.textContent = message;
    uploadProgress.style.color = isError ? 'var(--danger)' : isSuccess ? 'var(--success)' : 'var(--text-muted)';
  }

  uploadBtn.addEventListener('click', () => {
    const file = fontFileInput.files && fontFileInput.files[0];
    if (!file) {
      showUploadProgress('Please select a font file first.', true);
      return;
    }

    const ext = file.name.toLowerCase().split('.').pop();
    if (ext !== 'ttf' && ext !== 'otf') {
      showUploadProgress('Only .ttf and .otf files are supported.', true);
      return;
    }

    if (file.size > 10 * 1024 * 1024) {
      showUploadProgress('File too large (max 10MB).', true);
      return;
    }

    uploadBtn.disabled = true;
    uploadBtn.textContent = 'Installing...';
    showUploadProgress('Uploading... 0%');

    const formData = new FormData();
    formData.append('font_file', file);

    const xhr = new XMLHttpRequest();
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = Math.round((e.loaded / e.total) * 100);
        if (percentComplete < 100) {
          showUploadProgress(`Uploading... ${percentComplete}%`);
        } else {
          showUploadProgress('Installing font...');
        }
      }
    });

    xhr.addEventListener('load', () => {
      try {
        const response = JSON.parse(xhr.responseText);
        if (xhr.status === 200 && response.success) {
          showUploadProgress(`Success! Font "${response.font_name}" installed. Refreshing page...`, false, true);
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        } else {
          showUploadProgress(`Error: ${response.error || 'Upload failed'}`, true);
          resetUploadButton();
        }
      } catch (e) {
        showUploadProgress('Error: Invalid server response', true);
        resetUploadButton();
      }
    });

    xhr.addEventListener('error', () => {
      showUploadProgress('Error: Upload failed', true);
      resetUploadButton();
    });

    xhr.open('POST', '/api/font/upload', true);
    xhr.setRequestHeader('X-CSRF-Token', csrfToken);
    xhr.send(formData);
  });

  function resetUploadButton() {
    uploadBtn.disabled = false;
    uploadBtn.textContent = 'Upload and install';
  }
</script>
{% endblock %}
